
/*
Copyright (c) Vanderbilt University, 2000-2001
ALL RIGHTS RESERVED
Vanderbilt University disclaims all warranties with regard to this
software, including all implied warranties of merchantability
and fitness.  In no event shall Vanderbilt University be liable for
any special, indirect or consequential damages or any damages
whatsoever resulting from loss of use, data or profits, whether
in an action of contract, negligence or other tortious action,
arising out of or in connection with the use or performance of
this software.


  Don't edit this file - edit the XSLT files in the /etc directory and regenerate this file.


  01/12/03	-	endre
				
				- regenerated the XSLT scripts
				- see changelog in the XSLT files

  Initially converted from XMI2Udm.xslt and Udm2XMI.xslt with the appropiate sed command

  		

*/

#include <string>

	std::string __xmi_to_udm_str;
	std::string __udm_to_xmi_str;

	void initXSLTstr()
	{
		static bool init = false;
		if(init) return;
		init = true;
		
		/* Generated with ..\..\bin\sed.exe -e "s/\"/\\\\\"/g;s/^/__udm_to_xmi_str += \"/;s/$/\";/" Udm2XMI.xslt*/
		
	__udm_to_xmi_str += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "<!--";
__udm_to_xmi_str += "Copyright (c) Vanderbilt University, 2000-2002";
__udm_to_xmi_str += "ALL RIGHTS RESERVED";
__udm_to_xmi_str += "Vanderbilt University disclaims all warranties with regard to this";
__udm_to_xmi_str += "software, including all implied warranties of merchantability";
__udm_to_xmi_str += "and fitness.  In no event shall Vanderbilt University be liable for";
__udm_to_xmi_str += "any special, indirect or consequential damages or any damages";
__udm_to_xmi_str += "whatsoever resulting from loss of use, data or profits, whether";
__udm_to_xmi_str += "in an action of contract, negligence or other tortious action,";
__udm_to_xmi_str += "arising out of or in connection with the use or performance of";
__udm_to_xmi_str += "this software.";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "File: 					UdmToXMI.XSLT";
__udm_to_xmi_str += "Author: 					Endre Magyari <endre.magyari@vanderbilt.edu>";
__udm_to_xmi_str += "Synopsis:				Converts a UDM UML metamodel to metainformation in XMI 1.0 format based on UML 1.3";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "CHANGELOG:";
__udm_to_xmi_str += "	11/28/03  -	minor bugfix with isNavigable attribute values";
__udm_to_xmi_str += "	11/30/02	-	error when generating generalizations, it did not worked that way with Xalan	";
__udm_to_xmi_str += "	11/24/02	-	fixed datatypes. Dut to a  Copy&Paste error,  the UDM Boolean data type was missing";
__udm_to_xmi_str += "	11/24/02	-	fixed typo when evaluating nonpersistent attribute of attribute, it was \"nonpersitent\"";
__udm_to_xmi_str += "	11/19/02	-	fixed some ordering problems in case of classes and assocclasses.";
__udm_to_xmi_str += "	11/19/02	-	first complete version. The output conforms to UML.DTD distributed by the OMG.";
__udm_to_xmi_str += "					all the UML features supported by UDM are supported and translated.";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	-->";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>";
__udm_to_xmi_str += "	<xsl:output  method='xml' version='1.0' encoding='UTF-8'  doctype-system='uml.dtd'   indent='yes'/>";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	<!-- Random generated UUIID prefix-->	";
__udm_to_xmi_str += "	<xsl:variable name='uuid_prefix'>-63--26--54-118-9b87f6:f1647ded57</xsl:variable>";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	<!-- _id is a key in the document to be transformed -->";
__udm_to_xmi_str += "	<xsl:key name='id' match='Class' use='@_id'/>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	<!-- All the XMI headers to be generated when the root element is matched -->";
__udm_to_xmi_str += "	<xsl:template match='/'>";
__udm_to_xmi_str += "		<XMI xmi.version='1.0'>";
__udm_to_xmi_str += "			<XMI.header>";
__udm_to_xmi_str += "	   			<XMI.documentation>";
__udm_to_xmi_str += "	   				<XMI.exporter>Mobies XMI exporter</XMI.exporter>";
__udm_to_xmi_str += "	   				<XMI.exporterVersion>1.30</XMI.exporterVersion>";
__udm_to_xmi_str += "	   			</XMI.documentation>";
__udm_to_xmi_str += "	   			<XMI.metamodel xmi.name='UML' xmi.version='1.3'/>";
__udm_to_xmi_str += "	 	 	</XMI.header>";
__udm_to_xmi_str += "	 		 <XMI.content>";
__udm_to_xmi_str += "				<xsl:apply-templates/>";
__udm_to_xmi_str += "			</XMI.content>";
__udm_to_xmi_str += "		</XMI>";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "	<!-- Attribute -->";
__udm_to_xmi_str += "	<xsl:template match='Attribute'>";
__udm_to_xmi_str += "		<Foundation.Core.Attribute>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "			<!-- We use generate-id() here. It will never be referenced-->";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "				<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "				<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.name><xsl:value-of select='@name'/></Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.visibility xmi.value='{@visibility}'/>";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "			<Foundation.Core.Feature.ownerScope xmi.value='instance'/>";
__udm_to_xmi_str += "			<Foundation.Core.StructuralFeature.multiplicity>";
__udm_to_xmi_str += "				<Foundation.Data_Types.Multiplicity xmi.id=\"{concat('FDTM_',generate-id())}\">";
__udm_to_xmi_str += "					<Foundation.Data_Types.Multiplicity.range>";
__udm_to_xmi_str += "						<Foundation.Data_Types.MultiplicityRange xmi.id=\"{concat('FDTMR_',generate-id())}\">";
__udm_to_xmi_str += "							<Foundation.Data_Types.MultiplicityRange.lower><xsl:value-of select='@min'/></Foundation.Data_Types.MultiplicityRange.lower>";
__udm_to_xmi_str += "							<Foundation.Data_Types.MultiplicityRange.upper><xsl:value-of select='@max'/></Foundation.Data_Types.MultiplicityRange.upper>";
__udm_to_xmi_str += "						</Foundation.Data_Types.MultiplicityRange>";
__udm_to_xmi_str += "					</Foundation.Data_Types.Multiplicity.range>";
__udm_to_xmi_str += "				</Foundation.Data_Types.Multiplicity>";
__udm_to_xmi_str += "			</Foundation.Core.StructuralFeature.multiplicity>";
__udm_to_xmi_str += "			<Foundation.Core.StructuralFeature.changeability xmi.value='changeable'/>";
__udm_to_xmi_str += "			<xsl:choose>";
__udm_to_xmi_str += "				<xsl:when test='@defvalue'>";
__udm_to_xmi_str += "					<Foundation.Core.Attribute.initialValue>";
__udm_to_xmi_str += "						<Foundation.Data_Types.Expression xmi.id=\"{concat('FDTE_',generate-id())}\">";
__udm_to_xmi_str += "							<Foundation.Data_Types.Expression.language>Java</Foundation.Data_Types.Expression.language>";
__udm_to_xmi_str += "							<Foundation.Data_Types.Expression.body><xsl:value-of select='@defvalue'/></Foundation.Data_Types.Expression.body>";
__udm_to_xmi_str += "						</Foundation.Data_Types.Expression>";
__udm_to_xmi_str += "		              	</Foundation.Core.Attribute.initialValue>";
__udm_to_xmi_str += "	              	</xsl:when>";
__udm_to_xmi_str += "              	</xsl:choose>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "              	<Foundation.Core.Feature.owner>";
__udm_to_xmi_str += "              		<Foundation.Core.Classifier xmi.idref=\"{concat('xmi.',substring-after(../@_id,'id'))}\"/>";
__udm_to_xmi_str += "              	</Foundation.Core.Feature.owner>";
__udm_to_xmi_str += "              	<Foundation.Core.StructuralFeature.type>";
__udm_to_xmi_str += "             			<Foundation.Core.Classifier xmi.idref=\"{concat('xmi.dt_',@type)}\"/>";
__udm_to_xmi_str += "              	</Foundation.Core.StructuralFeature.type>";
__udm_to_xmi_str += "              	<Foundation.Core.ModelElement.taggedValue>";
__udm_to_xmi_str += "				<Foundation.Extension_Mechanisms.TaggedValue xmi.id=\"{concat('FEMTVT_',generate-id())}\">";
__udm_to_xmi_str += "					<Foundation.Extension_Mechanisms.TaggedValue.tag>transient</Foundation.Extension_Mechanisms.TaggedValue.tag>";
__udm_to_xmi_str += "		              	<Foundation.Extension_Mechanisms.TaggedValue.value>false</Foundation.Extension_Mechanisms.TaggedValue.value>";
__udm_to_xmi_str += "		              	<Foundation.Extension_Mechanisms.TaggedValue.modelElement>";
__udm_to_xmi_str += "		              		<Foundation.Core.ModelElement xmi.idref=\"{generate-id()}\"/>";
__udm_to_xmi_str += "		              	</Foundation.Extension_Mechanisms.TaggedValue.modelElement>";
__udm_to_xmi_str += "				</Foundation.Extension_Mechanisms.TaggedValue>";
__udm_to_xmi_str += "	             <Foundation.Extension_Mechanisms.TaggedValue xmi.id=\"{concat('FEMTVV_',generate-id())}\">";
__udm_to_xmi_str += "				<Foundation.Extension_Mechanisms.TaggedValue.tag>volatile</Foundation.Extension_Mechanisms.TaggedValue.tag>";
__udm_to_xmi_str += "	                  	<Foundation.Extension_Mechanisms.TaggedValue.value><xsl:value-of select='@nonpersistent'/></Foundation.Extension_Mechanisms.TaggedValue.value>";
__udm_to_xmi_str += "	                  	<Foundation.Extension_Mechanisms.TaggedValue.modelElement>";
__udm_to_xmi_str += "	                  		<Foundation.Core.ModelElement xmi.idref='{generate-id()}'/>";
__udm_to_xmi_str += "	                  	</Foundation.Extension_Mechanisms.TaggedValue.modelElement>";
__udm_to_xmi_str += "				</Foundation.Extension_Mechanisms.TaggedValue>";
__udm_to_xmi_str += "			</Foundation.Core.ModelElement.taggedValue>";
__udm_to_xmi_str += "		</Foundation.Core.Attribute>";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "	<!-- AssociationRole -->";
__udm_to_xmi_str += "	<xsl:template match='AssociationRole'>";
__udm_to_xmi_str += "		<Foundation.Core.AssociationEnd>";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "			<!-- We use generate-id() here. It will never be referenced-->";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "				<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "				<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "				<xsl:value-of select='@name'/>";
__udm_to_xmi_str += "			</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.visibility xmi.value='public'/>";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.isNavigable>";
__udm_to_xmi_str += "	              	<xsl:attribute name='xmi.value'>";
__udm_to_xmi_str += "		              	<xsl:choose>";
__udm_to_xmi_str += "						<xsl:when test='@isNavigable'>";
__udm_to_xmi_str += "							<xsl:value-of select='@isNavigable'/>";
__udm_to_xmi_str += "						</xsl:when>";
__udm_to_xmi_str += "						<xsl:otherwise>	";
__udm_to_xmi_str += "							<xsl:text>true</xsl:text>";
__udm_to_xmi_str += "						</xsl:otherwise>";
__udm_to_xmi_str += "					</xsl:choose>";
__udm_to_xmi_str += "				</xsl:attribute>";
__udm_to_xmi_str += "	              </Foundation.Core.AssociationEnd.isNavigable>";
__udm_to_xmi_str += "	             <Foundation.Core.AssociationEnd.ordering xmi.value='unordered'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.aggregation xmi.value='none'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.targetScope xmi.value='instance'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.multiplicity>";
__udm_to_xmi_str += "				<Foundation.Data_Types.Multiplicity xmi.id=\"{concat('FDTM_',generate-id())}\">";
__udm_to_xmi_str += "					<Foundation.Data_Types.Multiplicity.range>";
__udm_to_xmi_str += "						<Foundation.Data_Types.MultiplicityRange xmi.id=\"{concat('FDTMR_', generate-id())}\">";
__udm_to_xmi_str += "							<Foundation.Data_Types.MultiplicityRange.lower><xsl:value-of select='@min'/></Foundation.Data_Types.MultiplicityRange.lower>";
__udm_to_xmi_str += "							<Foundation.Data_Types.MultiplicityRange.upper><xsl:value-of select='@max'/></Foundation.Data_Types.MultiplicityRange.upper>";
__udm_to_xmi_str += "						</Foundation.Data_Types.MultiplicityRange>";
__udm_to_xmi_str += "					</Foundation.Data_Types.Multiplicity.range>";
__udm_to_xmi_str += "				</Foundation.Data_Types.Multiplicity>";
__udm_to_xmi_str += "			</Foundation.Core.AssociationEnd.multiplicity>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.changeability xmi.value='changeable'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.association>";
__udm_to_xmi_str += "				<Foundation.Core.Association xmi.idref='{generate-id(..)}'>";
__udm_to_xmi_str += "					<!-- if parent has attribute @assocClass than we use it's @assocClass as idref";
__udm_to_xmi_str += "						if not, generate-id(..)-->";
__udm_to_xmi_str += "					<xsl:attribute name='xmi.idref'>";
__udm_to_xmi_str += "						<xsl:choose>";
__udm_to_xmi_str += "							<xsl:when test='../@assocClass'>";
__udm_to_xmi_str += "								<xsl:value-of select=\"concat('xmi.',substring-after(../@assocClass,'id'))\"/>";
__udm_to_xmi_str += "							</xsl:when>";
__udm_to_xmi_str += "							<xsl:otherwise>";
__udm_to_xmi_str += "								<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "							</xsl:otherwise>";
__udm_to_xmi_str += "						</xsl:choose>";
__udm_to_xmi_str += "					</xsl:attribute>";
__udm_to_xmi_str += "				</Foundation.Core.Association>";
__udm_to_xmi_str += "			</Foundation.Core.AssociationEnd.association>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.type>";
__udm_to_xmi_str += "				<!-- this points to a class -->";
__udm_to_xmi_str += "				<Foundation.Core.Classifier xmi.idref=\"{concat('xmi.',substring-after(@target,'id'))}\"/>";
__udm_to_xmi_str += "			</Foundation.Core.AssociationEnd.type>";
__udm_to_xmi_str += "		</Foundation.Core.AssociationEnd>";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "	<!-- CompositionChildRole -->";
__udm_to_xmi_str += "	<xsl:template match='CompositionChildRole'>";
__udm_to_xmi_str += "		<Foundation.Core.AssociationEnd>";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "			<!-- We use generate-id() here. It will never be referenced-->";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "				<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "				<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "				<xsl:value-of select='@name'/>";
__udm_to_xmi_str += "			</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.visibility xmi.value='public'/>";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.isNavigable>";
__udm_to_xmi_str += "	              	<xsl:attribute name='xmi.value'>";
__udm_to_xmi_str += "		              	<xsl:choose>";
__udm_to_xmi_str += "						<xsl:when test='@isNavigable'>";
__udm_to_xmi_str += "							<xsl:value-of select='@isNavigable'/>";
__udm_to_xmi_str += "						</xsl:when>";
__udm_to_xmi_str += "						<xsl:otherwise>";
__udm_to_xmi_str += "							<xsl:text>true</xsl:text>";
__udm_to_xmi_str += "						</xsl:otherwise>";
__udm_to_xmi_str += "					</xsl:choose>";
__udm_to_xmi_str += "				</xsl:attribute>";
__udm_to_xmi_str += "	              </Foundation.Core.AssociationEnd.isNavigable>";
__udm_to_xmi_str += "	             <Foundation.Core.AssociationEnd.ordering xmi.value='unordered'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.aggregation xmi.value='none'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.targetScope xmi.value='instance'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.multiplicity>";
__udm_to_xmi_str += "				<Foundation.Data_Types.Multiplicity xmi.id=\"{concat('FDTM_',generate-id())}\">";
__udm_to_xmi_str += "					<Foundation.Data_Types.Multiplicity.range>";
__udm_to_xmi_str += "						<Foundation.Data_Types.MultiplicityRange xmi.id=\"{concat('FDTMR_', generate-id())}\">";
__udm_to_xmi_str += "							<Foundation.Data_Types.MultiplicityRange.lower><xsl:value-of select='@min'/></Foundation.Data_Types.MultiplicityRange.lower>";
__udm_to_xmi_str += "							<Foundation.Data_Types.MultiplicityRange.upper><xsl:value-of select='@max'/></Foundation.Data_Types.MultiplicityRange.upper>";
__udm_to_xmi_str += "						</Foundation.Data_Types.MultiplicityRange>";
__udm_to_xmi_str += "					</Foundation.Data_Types.Multiplicity.range>";
__udm_to_xmi_str += "				</Foundation.Data_Types.Multiplicity>";
__udm_to_xmi_str += "			</Foundation.Core.AssociationEnd.multiplicity>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.changeability xmi.value='changeable'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.association>";
__udm_to_xmi_str += "				<Foundation.Core.Association xmi.idref='{generate-id(..)}'/>";
__udm_to_xmi_str += "			</Foundation.Core.AssociationEnd.association>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.type>";
__udm_to_xmi_str += "				<!-- this points to a class -->";
__udm_to_xmi_str += "				<Foundation.Core.Classifier xmi.idref=\"{concat('xmi.',substring-after(@target,'id'))}\"/>";
__udm_to_xmi_str += "			</Foundation.Core.AssociationEnd.type>";
__udm_to_xmi_str += "		</Foundation.Core.AssociationEnd>";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "	<!-- CompositionParentRole -->";
__udm_to_xmi_str += "	<!-- this translates int an XMI AssociationEnd with aggregation = 'composite', ";
__udm_to_xmi_str += "		multiplicity=[1,1], classifier = target class, and association = parent node -->";
__udm_to_xmi_str += "	<xsl:template match='CompositionParentRole'>";
__udm_to_xmi_str += "		<Foundation.Core.AssociationEnd>		";
__udm_to_xmi_str += "			<!-- We use generate-id() here. It will never be referenced-->";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "				<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "				<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "	              <Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "	              	<xsl:value-of select='@name'/>";
__udm_to_xmi_str += "	              </Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "	              ";
__udm_to_xmi_str += "	              <Foundation.Core.ModelElement.visibility xmi.value='public'/>";
__udm_to_xmi_str += "	              <Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "	              <Foundation.Core.AssociationEnd.isNavigable>";
__udm_to_xmi_str += "	              	<xsl:attribute name='xmi.value'>";
__udm_to_xmi_str += "		              	<xsl:choose>";
__udm_to_xmi_str += "						<xsl:when test='@isNavigable'>";
__udm_to_xmi_str += "							<xsl:value-of select='@isNavigable'/>";
__udm_to_xmi_str += "						</xsl:when>";
__udm_to_xmi_str += "						<xsl:otherwise>	";
__udm_to_xmi_str += "							<xsl:text>true</xsl:text>";
__udm_to_xmi_str += "						</xsl:otherwise>";
__udm_to_xmi_str += "					</xsl:choose>";
__udm_to_xmi_str += "				</xsl:attribute>";
__udm_to_xmi_str += "	              </Foundation.Core.AssociationEnd.isNavigable>";
__udm_to_xmi_str += "	              <Foundation.Core.AssociationEnd.ordering xmi.value='unordered'/>";
__udm_to_xmi_str += "	              <Foundation.Core.AssociationEnd.aggregation xmi.value='composite'/>";
__udm_to_xmi_str += "	              <Foundation.Core.AssociationEnd.targetScope xmi.value='instance'/>";
__udm_to_xmi_str += "	              <Foundation.Core.AssociationEnd.multiplicity>";
__udm_to_xmi_str += "	              	<Foundation.Data_Types.Multiplicity xmi.id=\"{concat('FDTM_', generate-id())}\">";
__udm_to_xmi_str += "					<Foundation.Data_Types.Multiplicity.range>";
__udm_to_xmi_str += "						<Foundation.Data_Types.MultiplicityRange xmi.id=\"{concat('FDTMR_',generate-id())}\">";
__udm_to_xmi_str += "							<Foundation.Data_Types.MultiplicityRange.lower>	1</Foundation.Data_Types.MultiplicityRange.lower>";
__udm_to_xmi_str += "		                      		<Foundation.Data_Types.MultiplicityRange.upper>	1</Foundation.Data_Types.MultiplicityRange.upper>";
__udm_to_xmi_str += "		                   		 </Foundation.Data_Types.MultiplicityRange>";
__udm_to_xmi_str += "		                   	</Foundation.Data_Types.Multiplicity.range>";
__udm_to_xmi_str += "		             </Foundation.Data_Types.Multiplicity>";
__udm_to_xmi_str += "	              </Foundation.Core.AssociationEnd.multiplicity>";
__udm_to_xmi_str += "	              ";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.changeability xmi.value='changeable'/>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.association>";
__udm_to_xmi_str += "				<Foundation.Core.Association xmi.idref='{generate-id(..)}'/>";
__udm_to_xmi_str += "	              </Foundation.Core.AssociationEnd.association>";
__udm_to_xmi_str += "			<Foundation.Core.AssociationEnd.type>";
__udm_to_xmi_str += "				<!-- this is a class -->";
__udm_to_xmi_str += "				<Foundation.Core.Classifier xmi.idref=\"{concat('xmi.',substring-after(@target,'id'))}\"/>";
__udm_to_xmi_str += "			</Foundation.Core.AssociationEnd.type>";
__udm_to_xmi_str += "		</Foundation.Core.AssociationEnd>			";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	<!-- Association -->";
__udm_to_xmi_str += "	<xsl:template match='Association'>";
__udm_to_xmi_str += "		<xsl:choose>";
__udm_to_xmi_str += "			<xsl:when test='@assocClass'>";
__udm_to_xmi_str += "				<Foundation.Core.AssociationClass>		";
__udm_to_xmi_str += "					<!--Since this is also a class, we may use the assocClass attribute value as id -->";
__udm_to_xmi_str += "					<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "						<xsl:value-of select=\"concat('xmi.',substring-after(@assocClass,'id'))\"/>";
__udm_to_xmi_str += "					</xsl:attribute>";
__udm_to_xmi_str += "					<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "						<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select=\"substring-after(@assocClass,'id')\"/>";
__udm_to_xmi_str += "					</xsl:attribute>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "					<!-- This the name of the association class pointed by assocClass and not the name of the association ! -->";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "						<xsl:for-each select=\"key('id',@assocClass)\">";
__udm_to_xmi_str += "							<!-- We rely on the fact that there is only one such attribute -->";
__udm_to_xmi_str += "							<xsl:value-of select='@name'/>";
__udm_to_xmi_str += "						</xsl:for-each>";
__udm_to_xmi_str += "					</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>					";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isAbstract>";
__udm_to_xmi_str += "						<xsl:attribute name='xmi.value'>";
__udm_to_xmi_str += "							<xsl:for-each select=\"key('id',@assocClass)\">";
__udm_to_xmi_str += "								<!-- We rely on the fact that there is only one such attribute -->";
__udm_to_xmi_str += "								<xsl:value-of select='@isAbstract'/>";
__udm_to_xmi_str += "							</xsl:for-each>";
__udm_to_xmi_str += "						</xsl:attribute>";
__udm_to_xmi_str += "					</Foundation.Core.GeneralizableElement.isAbstract>";
__udm_to_xmi_str += "				";
__udm_to_xmi_str += "					<!-- Namespace -->";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "						<Foundation.Core.Namespace xmi.idref='{generate-id(..)}'/>";
__udm_to_xmi_str += "		          		</Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "		          	";
__udm_to_xmi_str += "					<!-- Inheritence -->";
__udm_to_xmi_str += "					<xsl:for-each select=\"key('id',@assocClass)\">	";
__udm_to_xmi_str += "						<!-- Inheritence: Generalization(Basetypes) -->";
__udm_to_xmi_str += "	          				<xsl:choose>";
__udm_to_xmi_str += "	          					<xsl:when test='@baseTypes'>";
__udm_to_xmi_str += "	          						<Foundation.Core.GeneralizableElement.generalization>";
__udm_to_xmi_str += "		          						<xsl:call-template name='gen_gen_references'>";
__udm_to_xmi_str += "										<xsl:with-param name='str' select='normalize-space(@baseTypes)'/>";
__udm_to_xmi_str += "										<xsl:with-param name='base' select='@_id'/>";
__udm_to_xmi_str += "										<xsl:with-param name='direction' select='false()'/>";
__udm_to_xmi_str += "									</xsl:call-template>";
__udm_to_xmi_str += "								</Foundation.Core.GeneralizableElement.generalization>";
__udm_to_xmi_str += "	          					</xsl:when>";
__udm_to_xmi_str += "	          				</xsl:choose>";
__udm_to_xmi_str += "						<!-- Inheritence: Specialization(Subtypes) -->";
__udm_to_xmi_str += "	          				<xsl:choose>";
__udm_to_xmi_str += "	          					<xsl:when test='@subTypes'>";
__udm_to_xmi_str += "	          						<Foundation.Core.GeneralizableElement.specialization>";
__udm_to_xmi_str += "		          						<xsl:call-template name='gen_gen_references'>";
__udm_to_xmi_str += "										<xsl:with-param name='str' select='normalize-space(@subTypes)'/>";
__udm_to_xmi_str += "										<xsl:with-param name='base' select='@_id'/>";
__udm_to_xmi_str += "										<xsl:with-param name='direction' select='true()'/>";
__udm_to_xmi_str += "									</xsl:call-template>";
__udm_to_xmi_str += "								</Foundation.Core.GeneralizableElement.specialization>";
__udm_to_xmi_str += "	          					</xsl:when>";
__udm_to_xmi_str += "	          				</xsl:choose>";
__udm_to_xmi_str += "					</xsl:for-each>";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "					<!-- AssociationRoles -->";
__udm_to_xmi_str += "					<Foundation.Core.Association.connection>";
__udm_to_xmi_str += "		          			<!-- go recursive, search for AssociationRoles -->";
__udm_to_xmi_str += "		          			<xsl:apply-templates/>";
__udm_to_xmi_str += "					</Foundation.Core.Association.connection>";
__udm_to_xmi_str += "					";
__udm_to_xmi_str += "					";
__udm_to_xmi_str += "					<xsl:for-each select=\"key('id',@assocClass)\">";
__udm_to_xmi_str += "						<!-- Attributes -->";
__udm_to_xmi_str += "						<xsl:choose>";
__udm_to_xmi_str += "							<xsl:when test='child::*'>";
__udm_to_xmi_str += "								<!-- The class has attributes -->";
__udm_to_xmi_str += "								<Foundation.Core.Classifier.feature>";
__udm_to_xmi_str += "									<!-- search for Attributes -->";
__udm_to_xmi_str += "									<xsl:apply-templates/>";
__udm_to_xmi_str += "		          					</Foundation.Core.Classifier.feature>";
__udm_to_xmi_str += "          						</xsl:when>";
__udm_to_xmi_str += "          					</xsl:choose>";
__udm_to_xmi_str += "					</xsl:for-each>";
__udm_to_xmi_str += "		          	</Foundation.Core.AssociationClass>";
__udm_to_xmi_str += "	          	</xsl:when>";
__udm_to_xmi_str += "	          	<xsl:otherwise>";
__udm_to_xmi_str += "	          		<Foundation.Core.Association>		";
__udm_to_xmi_str += "					<!--we use generate ID here.  -->";
__udm_to_xmi_str += "					<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "						<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "					</xsl:attribute>";
__udm_to_xmi_str += "					<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "						<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "					</xsl:attribute>";
__udm_to_xmi_str += "					";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "						<xsl:value-of select='@name'/>";
__udm_to_xmi_str += "					</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>					";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isAbstract xmi.value='false'/>	";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "						<Foundation.Core.Namespace xmi.idref='{generate-id(..)}'/>";
__udm_to_xmi_str += "		          		</Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "		          		<Foundation.Core.Association.connection>";
__udm_to_xmi_str += "		          			<!-- go recursive, search for AssociationRoles -->";
__udm_to_xmi_str += "		          			<xsl:apply-templates/>";
__udm_to_xmi_str += "					</Foundation.Core.Association.connection>";
__udm_to_xmi_str += "		          	</Foundation.Core.Association>";
__udm_to_xmi_str += "	          	</xsl:otherwise>";
__udm_to_xmi_str += "		</xsl:choose>";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "		";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "	<!-- Composition -->";
__udm_to_xmi_str += "	<xsl:template match='Composition'>";
__udm_to_xmi_str += "		<Foundation.Core.Association>	";
__udm_to_xmi_str += "			<!-- We use generate-id() here. It will never be referenced-->";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "				<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "				<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "		";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "				<xsl:value-of select='@name'/>";
__udm_to_xmi_str += "			</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "			<Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "			<Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>					";
__udm_to_xmi_str += "			<Foundation.Core.GeneralizableElement.isAbstract xmi.value='false'/>	";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "				<Foundation.Core.Namespace xmi.idref='{generate-id(..)}'/>";
__udm_to_xmi_str += "          		</Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "          		<Foundation.Core.Association.connection>";
__udm_to_xmi_str += "          			<!-- go recursive -->";
__udm_to_xmi_str += "          			<xsl:apply-templates/>";
__udm_to_xmi_str += "			</Foundation.Core.Association.connection>";
__udm_to_xmi_str += "          	</Foundation.Core.Association>";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "	<!-- Class -->		";
__udm_to_xmi_str += "	<xsl:template match='Class'>";
__udm_to_xmi_str += "		<!-- we should skip the declaration if the class is an association class,";
__udm_to_xmi_str += "			because it gets generated as an Fundation.Core.AssociationClass";
__udm_to_xmi_str += "			 upon the <Association> elements -->";
__udm_to_xmi_str += "		<xsl:choose>";
__udm_to_xmi_str += "			<xsl:when test='not(@association)'>";
__udm_to_xmi_str += "				<Foundation.Core.Class>";
__udm_to_xmi_str += "					<!-- The attribute id needs to be computed -->";
__udm_to_xmi_str += "					<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "						<xsl:choose>";
__udm_to_xmi_str += "							<xsl:when test='@_id'>";
__udm_to_xmi_str += "								<xsl:value-of select=\"concat('xmi.',substring-after(@_id,'id'))\"/>";
__udm_to_xmi_str += "							</xsl:when>";
__udm_to_xmi_str += "							<xsl:otherwise>";
__udm_to_xmi_str += "								<xsl:message terminate='yes'>";
__udm_to_xmi_str += "									Class <xsl:value-of select='@name'/> does not have a mandatory id attribute!";
__udm_to_xmi_str += "								</xsl:message>";
__udm_to_xmi_str += "							</xsl:otherwise>";
__udm_to_xmi_str += "						</xsl:choose>";
__udm_to_xmi_str += "					</xsl:attribute>";
__udm_to_xmi_str += "				";
__udm_to_xmi_str += "					<!-- The attribute uuid will be prefix + generated-id -->			";
__udm_to_xmi_str += "					<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "						<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "					</xsl:attribute>	";
__udm_to_xmi_str += "					";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "						<xsl:value-of select='@name'/>";
__udm_to_xmi_str += "					</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isAbstract xmi.value='{@isAbstract}'/>";
__udm_to_xmi_str += "					<Foundation.Core.Class.isActive xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "						<Foundation.Core.Namespace xmi.idref='{generate-id(..)}'/>";
__udm_to_xmi_str += "					</Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "					<!-- Inheritence: Generalization(Basetypes) -->";
__udm_to_xmi_str += "          				<xsl:choose>";
__udm_to_xmi_str += "          					<xsl:when test='@baseTypes'>";
__udm_to_xmi_str += "          						<Foundation.Core.GeneralizableElement.generalization>";
__udm_to_xmi_str += "	          						<xsl:call-template name='gen_gen_references'>";
__udm_to_xmi_str += "									<xsl:with-param name='str' select='normalize-space(@baseTypes)'/>";
__udm_to_xmi_str += "									<xsl:with-param name='base' select='@_id'/>";
__udm_to_xmi_str += "									<xsl:with-param name='direction' select='false()'/>";
__udm_to_xmi_str += "								</xsl:call-template>";
__udm_to_xmi_str += "							</Foundation.Core.GeneralizableElement.generalization>";
__udm_to_xmi_str += "          					</xsl:when>";
__udm_to_xmi_str += "          				</xsl:choose>";
__udm_to_xmi_str += "					<!-- Inheritence: Specialization(Subtypes) -->";
__udm_to_xmi_str += "          				<xsl:choose>";
__udm_to_xmi_str += "          					<xsl:when test='@subTypes'>";
__udm_to_xmi_str += "          						<Foundation.Core.GeneralizableElement.specialization>";
__udm_to_xmi_str += "	          						<xsl:call-template name='gen_gen_references'>";
__udm_to_xmi_str += "									<xsl:with-param name='str' select='normalize-space(@subTypes)'/>";
__udm_to_xmi_str += "									<xsl:with-param name='base' select='@_id'/>";
__udm_to_xmi_str += "									<xsl:with-param name='direction' select='true()'/>";
__udm_to_xmi_str += "								</xsl:call-template>";
__udm_to_xmi_str += "							</Foundation.Core.GeneralizableElement.specialization>";
__udm_to_xmi_str += "          					</xsl:when>";
__udm_to_xmi_str += "          				</xsl:choose>";
__udm_to_xmi_str += "					";
__udm_to_xmi_str += "					<!-- Attributes -->";
__udm_to_xmi_str += "					<xsl:choose>";
__udm_to_xmi_str += "						<xsl:when test='child::*'>";
__udm_to_xmi_str += "							<Foundation.Core.Classifier.feature>";
__udm_to_xmi_str += "								<xsl:apply-templates/>";
__udm_to_xmi_str += "		          				</Foundation.Core.Classifier.feature>";
__udm_to_xmi_str += "          					</xsl:when>";
__udm_to_xmi_str += "          				</xsl:choose>";
__udm_to_xmi_str += "		        	</Foundation.Core.Class>";
__udm_to_xmi_str += "		        </xsl:when>";
__udm_to_xmi_str += "		        <xsl:otherwise/><!-- Class is an Association Class. It will declared as such -->";
__udm_to_xmi_str += "        	</xsl:choose>	 ";
__udm_to_xmi_str += "		";
__udm_to_xmi_str += "   	</xsl:template>";
__udm_to_xmi_str += "";
__udm_to_xmi_str += "	<!-- recursive template to generate the references to generalization elements in class elements,";
__udm_to_xmi_str += "	in case of generalizations and specializations -->";
__udm_to_xmi_str += "	<xsl:template name='gen_gen_references'>";
__udm_to_xmi_str += "		<xsl:param name='str'/>";
__udm_to_xmi_str += "		<xsl:param name='base'/>";
__udm_to_xmi_str += "		<xsl:param name='direction'/>";
__udm_to_xmi_str += "		<xsl:if test='string-length($str) > 0'>";
__udm_to_xmi_str += "			<!-- computing the derived id -->";
__udm_to_xmi_str += "			<xsl:variable name='derived'>";
__udm_to_xmi_str += "				<xsl:choose>";
__udm_to_xmi_str += "					<xsl:when test=\"contains($str, ' ')\">";
__udm_to_xmi_str += "						<xsl:value-of select=\"substring-before($str, ' ')\"/>";
__udm_to_xmi_str += "					</xsl:when>";
__udm_to_xmi_str += "					<xsl:otherwise>";
__udm_to_xmi_str += "						<xsl:value-of select='$str'/>";
__udm_to_xmi_str += "					</xsl:otherwise>";
__udm_to_xmi_str += "				</xsl:choose> ";
__udm_to_xmi_str += "			</xsl:variable>";
__udm_to_xmi_str += "			<!-- generate some output-->";
__udm_to_xmi_str += "			<Foundation.Core.Generalization>";
__udm_to_xmi_str += "				<xsl:attribute name='xmi.idref'>";
__udm_to_xmi_str += "					<xsl:choose>";
__udm_to_xmi_str += "						<xsl:when test='$direction = true()'>";
__udm_to_xmi_str += "							<xsl:value-of select=\"concat('xmi.gen_', concat($base, $derived))\"/>";
__udm_to_xmi_str += "						</xsl:when>";
__udm_to_xmi_str += "						<xsl:otherwise>";
__udm_to_xmi_str += "							<xsl:value-of select=\"concat('xmi.gen_', concat($derived, $base))\"/>";
__udm_to_xmi_str += "						</xsl:otherwise>";
__udm_to_xmi_str += "					</xsl:choose>";
__udm_to_xmi_str += "				</xsl:attribute>";
__udm_to_xmi_str += "			</Foundation.Core.Generalization>";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "			<!-- recursive step -->";
__udm_to_xmi_str += "			<xsl:call-template name='gen_gen_references'>";
__udm_to_xmi_str += "				<xsl:with-param name='str' select=\"normalize-space(substring-after($str, ' '))\"/>";
__udm_to_xmi_str += "				<xsl:with-param name='base' select='$base'/>";
__udm_to_xmi_str += "				<xsl:with-param name='direction' select='$direction'/>";
__udm_to_xmi_str += "			</xsl:call-template>";
__udm_to_xmi_str += "		</xsl:if>";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	<!-- recursive template to generate generalization elements from string idref list -->";
__udm_to_xmi_str += "	<xsl:template name='tokenize'>";
__udm_to_xmi_str += "		<xsl:param name='str'/>";
__udm_to_xmi_str += "		<xsl:param name='base'/>		";
__udm_to_xmi_str += "		<xsl:if test='string-length($str) > 0'>";
__udm_to_xmi_str += "			<Foundation.Core.Generalization>";
__udm_to_xmi_str += "				";
__udm_to_xmi_str += "				<!-- computing the derived id -->";
__udm_to_xmi_str += "				<xsl:variable name='derived'>";
__udm_to_xmi_str += "						<xsl:choose>";
__udm_to_xmi_str += "							<xsl:when test=\"contains($str, ' ')\">";
__udm_to_xmi_str += "								<xsl:value-of select=\"substring-before($str, ' ')\"/>";
__udm_to_xmi_str += "							</xsl:when>";
__udm_to_xmi_str += "							<xsl:otherwise>";
__udm_to_xmi_str += "								<xsl:value-of select='$str'/>";
__udm_to_xmi_str += "							</xsl:otherwise>";
__udm_to_xmi_str += "						</xsl:choose> ";
__udm_to_xmi_str += "				</xsl:variable>";
__udm_to_xmi_str += "				";
__udm_to_xmi_str += "				<!-- this generalization element must be referenced in the Class element either as specialization or as generalization,";
__udm_to_xmi_str += "				so we will generate some IDs which can be easily computed while matching the class elements as well. -->";
__udm_to_xmi_str += "				<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "					<xsl:value-of select=\"concat('xmi.gen_', concat($base, $derived))\"/>";
__udm_to_xmi_str += "				</xsl:attribute>";
__udm_to_xmi_str += "				";
__udm_to_xmi_str += "				<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "					<xsl:value-of select=\"concat($uuid_prefix, concat($base, $derived))\"/>";
__udm_to_xmi_str += "				</xsl:attribute>";
__udm_to_xmi_str += "				";
__udm_to_xmi_str += "				<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "				<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "					<!-- Namespace is the generate-id() for the diagram, which is the parent of the base class-->";
__udm_to_xmi_str += "					<xsl:for-each select=\"key('id', $base)\">";
__udm_to_xmi_str += "						<Foundation.Core.Namespace xmi.idref='{generate-id(..)}'/>";
__udm_to_xmi_str += "					</xsl:for-each>";
__udm_to_xmi_str += "				</Foundation.Core.ModelElement.namespace>				";
__udm_to_xmi_str += "				<Foundation.Core.Generalization.child>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement xmi.idref=\"{concat('xmi.',substring-after($derived,'id'))}\"/>";
__udm_to_xmi_str += "				</Foundation.Core.Generalization.child>";
__udm_to_xmi_str += "				<Foundation.Core.Generalization.parent>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement xmi.idref=\"{concat('xmi.',substring-after($base,'id'))}\"/>";
__udm_to_xmi_str += "	          		</Foundation.Core.Generalization.parent>";
__udm_to_xmi_str += "			</Foundation.Core.Generalization>";
__udm_to_xmi_str += "			<xsl:call-template name='tokenize'>";
__udm_to_xmi_str += "				<xsl:with-param name='str' select=\"normalize-space(substring-after($str, ' '))\"/>";
__udm_to_xmi_str += "				<xsl:with-param name='base' select='$base'/>";
__udm_to_xmi_str += "			</xsl:call-template>";
__udm_to_xmi_str += "		</xsl:if>";
__udm_to_xmi_str += "	</xsl:template>";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	<!-- Inheritence -->	";
__udm_to_xmi_str += "	<xsl:template name='generalizations'>";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "		<!-- TODO! -->";
__udm_to_xmi_str += "		<xsl:for-each select='Class'>";
__udm_to_xmi_str += "			<xsl:variable name='base' select='@_id'/>";
__udm_to_xmi_str += "			<xsl:for-each select='@subTypes'>";
__udm_to_xmi_str += "					<xsl:call-template name='tokenize'>";
__udm_to_xmi_str += "					<xsl:with-param name='str' select=\"normalize-space(.)\"/>";
__udm_to_xmi_str += "					<xsl:with-param name='base' select='$base'/>";
__udm_to_xmi_str += "				</xsl:call-template>";
__udm_to_xmi_str += "			</xsl:for-each>";
__udm_to_xmi_str += "		</xsl:for-each>";
__udm_to_xmi_str += "	</xsl:template>	";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	";
__udm_to_xmi_str += "	<!-- The root of the input XML is always a Diagram-->";
__udm_to_xmi_str += "	<xsl:template match='Diagram'>";
__udm_to_xmi_str += "		<Model_Management.Model>";
__udm_to_xmi_str += "		";
__udm_to_xmi_str += "			<!-- We use generate-id() here. It will be referenced from all classes-->";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.id'>";
__udm_to_xmi_str += "				<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>";
__udm_to_xmi_str += "			<xsl:attribute name='xmi.uuid'>";
__udm_to_xmi_str += "				<xsl:value-of select='$uuid_prefix'/>:<xsl:value-of select='generate-id()'/>";
__udm_to_xmi_str += "			</xsl:attribute>	";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "				<xsl:value-of select='@name'/>";
__udm_to_xmi_str += "			</Foundation.Core.ModelElement.name>				";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "			<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "		      <Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "		      <Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>";
__udm_to_xmi_str += "		      <Foundation.Core.GeneralizableElement.isAbstract xmi.value='false'/>";
__udm_to_xmi_str += "		      <Foundation.Core.Namespace.ownedElement>";
__udm_to_xmi_str += "		      <!-- Go recursive -->";
__udm_to_xmi_str += "				<xsl:apply-templates/>";
__udm_to_xmi_str += "			<!-- Add inheritence relationships -->";
__udm_to_xmi_str += "			<xsl:call-template name='generalizations'/>";
__udm_to_xmi_str += "			";
__udm_to_xmi_str += "			<!-- Define datatypes -->";
__udm_to_xmi_str += "				<!--Integer -->";
__udm_to_xmi_str += "				 <Foundation.Core.DataType xmi.id='xmi.dt_Integer'>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.name>Integer</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isAbstract xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "						<Foundation.Core.Namespace xmi.idref='{generate-id()}'/>";
__udm_to_xmi_str += "					</Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "	       		</Foundation.Core.DataType>";
__udm_to_xmi_str += "	       		<!--String -->";
__udm_to_xmi_str += "				 <Foundation.Core.DataType xmi.id='xmi.dt_String'>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.name>String</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isAbstract xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "						<Foundation.Core.Namespace xmi.idref='{generate-id()}'/>";
__udm_to_xmi_str += "					</Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "	       		</Foundation.Core.DataType>";
__udm_to_xmi_str += "	       		<!--Boolean -->";
__udm_to_xmi_str += "				 <Foundation.Core.DataType xmi.id='xmi.dt_Boolean'>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.name>Boolean</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isAbstract xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "						<Foundation.Core.Namespace xmi.idref='{generate-id()}'/>";
__udm_to_xmi_str += "					</Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "	       		</Foundation.Core.DataType>";
__udm_to_xmi_str += "	       		<!--Real -->";
__udm_to_xmi_str += "				 <Foundation.Core.DataType xmi.id='xmi.dt_Real'>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.name>Real</Foundation.Core.ModelElement.name>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.isSpecification xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isRoot xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isLeaf xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.GeneralizableElement.isAbstract xmi.value='false'/>";
__udm_to_xmi_str += "					<Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "								<Foundation.Core.Namespace xmi.idref='{generate-id()}'/>";
__udm_to_xmi_str += "                   </Foundation.Core.ModelElement.namespace>";
__udm_to_xmi_str += "                   </Foundation.Core.DataType>";
__udm_to_xmi_str += "                   </Foundation.Core.Namespace.ownedElement>";
__udm_to_xmi_str += "           </Model_Management.Model>";
__udm_to_xmi_str += "   </xsl:template>";
__udm_to_xmi_str += "</xsl:stylesheet>";


		/* Generated with: ..\..\bin\sed.exe -e "s/\"/\\\\\"/g;s/^/__xmi_to_udm_str += \"/;s/$/\";/" XMI2Udm.xslt*/
		
		__xmi_to_udm_str += "<?xml version=\"1.0\" encoding=\"UTF-8\"?>";
__xmi_to_udm_str += "<!--%%";
__xmi_to_udm_str += "Copyright (c) Vanderbilt University, 2000-2002";
__xmi_to_udm_str += "ALL RIGHTS RESERVED";
__xmi_to_udm_str += "Vanderbilt University disclaims all warranties with regard to this";
__xmi_to_udm_str += "software, including all implied warranties of merchantability";
__xmi_to_udm_str += "and fitness.  In no event shall Vanderbilt University be liable for";
__xmi_to_udm_str += "any special, indirect or consequential damages or any damages";
__xmi_to_udm_str += "whatsoever resulting from loss of use, data or profits, whether";
__xmi_to_udm_str += "in an action of contract, negligence or other tortious action,";
__xmi_to_udm_str += "arising out of or in connection with the use or performance of";
__xmi_to_udm_str += "this software.";
__xmi_to_udm_str += "%";
__xmi_to_udm_str += "File: 					XMI2Udm.XSLT";
__xmi_to_udm_str += "Author: 					Endre Magyari <endre.magyari@vanderbilt.edu>";
__xmi_to_udm_str += "Synopsis:				Converts an XMI 1.0/UML 1.3 format metainformation to UDM UML metamodell";
__xmi_to_udm_str += "CHANGELOG:";
__xmi_to_udm_str += "%	";
__xmi_to_udm_str += "	28/11/03	-	Changed to produce XSD based output instead of DTD";
__xmi_to_udm_str += "	05/19/03	-	Minor Bug: Composition shoud have it's subelements ordered";
__xmi_to_udm_str += "	11/25/02	-	first complete version. The output conforms to UML.DTD distributed by the MoBIES/UDM";
__xmi_to_udm_str += "					all the UML features supported by UDM are supported and translated.";
__xmi_to_udm_str += "%";
__xmi_to_udm_str += "%-->";
__xmi_to_udm_str += "<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\">";
__xmi_to_udm_str += "	<xsl:output method=\"xml\" version=\"1.0\" encoding=\"UTF-8\" indent=\"yes\" />";
__xmi_to_udm_str += "	<xsl:key name=\"id\" match=\"node()\" use=\"@xmi.id\"/>";
__xmi_to_udm_str += "	<!-- xmi.id is a key in the document to be transformed -->";
__xmi_to_udm_str += "	<xsl:template name=\"Foundation.Core.Classifier.feature\">";
__xmi_to_udm_str += "		<!-- Classifier Features -->";
__xmi_to_udm_str += "		<xsl:apply-templates select=\"Foundation.Core.Attribute\"/>";
__xmi_to_udm_str += "	</xsl:template>";
__xmi_to_udm_str += "	<xsl:template match=\"Foundation.Core.Attribute\">";
__xmi_to_udm_str += "		<!-- Attributes -->";
__xmi_to_udm_str += "		<Attribute name=\"{Foundation.Core.ModelElement.name}\" min=\"{Foundation.Core.StructuralFeature.multiplicity/Foundation.Data_Types.Multiplicity/Foundation.Data_Types.Multiplicity.range/Foundation.Data_Types.MultiplicityRange/Foundation.Data_Types.MultiplicityRange.lower}\" max=\"{Foundation.Core.StructuralFeature.multiplicity/Foundation.Data_Types.Multiplicity/Foundation.Data_Types.Multiplicity.range/Foundation.Data_Types.MultiplicityRange/Foundation.Data_Types.MultiplicityRange.upper}\" visibility=\"{Foundation.Core.ModelElement.visibility/@xmi.value}\" ordered=\"false\">";
__xmi_to_udm_str += "			<!-- nonpersistent is a taggedvalue named volatile -->";
__xmi_to_udm_str += "			<xsl:for-each select=\"Foundation.Core.ModelElement.taggedValue/Foundation.Extension_Mechanisms.TaggedValue\">";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string(Foundation.Extension_Mechanisms.TaggedValue.tag) = 'volatile'\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"nonpersistent\"><xsl:value-of select=\"Foundation.Extension_Mechanisms.TaggedValue.value\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "			</xsl:for-each>";
__xmi_to_udm_str += "			<!-- defval is Foundation.Core.Attribute.initial -->";
__xmi_to_udm_str += "			<xsl:for-each select=\"Foundation.Core.Attribute.initialValue/Foundation.Data_Types.Expression\">";
__xmi_to_udm_str += "				<xsl:attribute name=\"defvalue\"><xsl:value-of select=\"Foundation.Data_Types.Expression.body\"/></xsl:attribute>";
__xmi_to_udm_str += "			</xsl:for-each>";
__xmi_to_udm_str += "			<!-- type is obtained via a key to a datatype -->";
__xmi_to_udm_str += "			<xsl:for-each select=\"key('id', Foundation.Core.StructuralFeature.type/Foundation.Core.Classifier/@xmi.idref)\">";
__xmi_to_udm_str += "				<xsl:attribute name=\"type\"><xsl:value-of select=\"Foundation.Core.ModelElement.name\"/></xsl:attribute>";
__xmi_to_udm_str += "			</xsl:for-each>";
__xmi_to_udm_str += "		</Attribute>";
__xmi_to_udm_str += "	</xsl:template>";
__xmi_to_udm_str += "	<!-- Namespace.ownedElement; do nothing, go recursive -->";
__xmi_to_udm_str += "	<xsl:template match=\"Foundation.Core.Namespace.ownedElement\">";
__xmi_to_udm_str += "		<!-- First, the association definitions, without association classes ";
__xmi_to_udm_str += "			(This is part of the Association definitions generation 	-->";
__xmi_to_udm_str += "		<xsl:for-each select=\"Foundation.Core.Association\">";
__xmi_to_udm_str += "			<xsl:variable name=\"assoc_pos\" select=\"number(position())\"/>";
__xmi_to_udm_str += "			<xsl:choose>";
__xmi_to_udm_str += "				<xsl:when test=\"count(Foundation.Core.Association.connection/Foundation.Core.AssociationEnd/Foundation.Core.AssociationEnd.aggregation[@xmi.value = 'composite']) = 0\">";
__xmi_to_udm_str += "					<Association _id=\"{concat('id', string(number($assoc_pos) + number($assoc_pos)*1000 + 400000))}\">";
__xmi_to_udm_str += "						<!-- Check if name exists -->";
__xmi_to_udm_str += "						<xsl:choose>";
__xmi_to_udm_str += "							<xsl:when test=\"string-length(Foundation.Core.ModelElement.name) > 1\">";
__xmi_to_udm_str += "								<xsl:attribute name=\"name\"><xsl:value-of select=\"Foundation.Core.ModelElement.name\"/></xsl:attribute>";
__xmi_to_udm_str += "							</xsl:when>";
__xmi_to_udm_str += "						</xsl:choose>";
__xmi_to_udm_str += "						<xsl:for-each select=\"Foundation.Core.Association.connection/Foundation.Core.AssociationEnd\">";
__xmi_to_udm_str += "							<AssociationRole _id=\"{concat('id',string(number($assoc_pos)*1000 + 500000 + position()))}\" min=\"{string(Foundation.Core.AssociationEnd.multiplicity/Foundation.Data_Types.Multiplicity/Foundation.Data_Types.Multiplicity.range/Foundation.Data_Types.MultiplicityRange/Foundation.Data_Types.MultiplicityRange.lower)}\" max=\"{string(Foundation.Core.AssociationEnd.multiplicity/Foundation.Data_Types.Multiplicity/Foundation.Data_Types.Multiplicity.range/Foundation.Data_Types.MultiplicityRange/Foundation.Data_Types.MultiplicityRange.upper)}\" target=\"{concat('id',substring-after(Foundation.Core.AssociationEnd.type/Foundation.Core.Classifier/@xmi.idref,'xmi.'))}\">";
__xmi_to_udm_str += "								<!-- Check if name exists -->";
__xmi_to_udm_str += "								<xsl:choose>";
__xmi_to_udm_str += "									<xsl:when test=\"string-length(Foundation.Core.ModelElement.name) > 1\">";
__xmi_to_udm_str += "										<xsl:attribute name=\"name\"><xsl:value-of select=\"Foundation.Core.ModelElement.name\"/></xsl:attribute>";
__xmi_to_udm_str += "									</xsl:when>";
__xmi_to_udm_str += "								</xsl:choose>";
__xmi_to_udm_str += "							</AssociationRole>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</Association>";
__xmi_to_udm_str += "				</xsl:when>";
__xmi_to_udm_str += "			</xsl:choose>";
__xmi_to_udm_str += "		</xsl:for-each>";
__xmi_to_udm_str += "		<!-- The  the association definitions, with association class ";
__xmi_to_udm_str += "			(this is still part of the Association definition generation -->";
__xmi_to_udm_str += "		<xsl:for-each select=\"Foundation.Core.AssociationClass\">";
__xmi_to_udm_str += "			<xsl:variable name=\"assoc_pos\" select=\"position() + count(../Foundation.Core.Association)\"/>";
__xmi_to_udm_str += "			<xsl:choose>";
__xmi_to_udm_str += "				<xsl:when test=\"count(Foundation.Core.Association.connection/Foundation.Core.AssociationEnd/Foundation.Core.AssociationEnd.aggregation[@xmi.value = 'composite']) = 0\">";
__xmi_to_udm_str += "					<Association _id=\"{concat('id', string(number($assoc_pos) + number($assoc_pos)*1000 + 400000))}\" assocClass=\"{concat('id', substring-after(@xmi.id,'xmi.'))}\">";
__xmi_to_udm_str += "						<!-- Check if name exists -->";
__xmi_to_udm_str += "						<xsl:choose>";
__xmi_to_udm_str += "							<xsl:when test=\"string-length(Foundation.Core.ModelElement.name) > 1\">";
__xmi_to_udm_str += "								<xsl:attribute name=\"name\"><xsl:value-of select=\"Foundation.Core.ModelElement.name\"/></xsl:attribute>";
__xmi_to_udm_str += "							</xsl:when>";
__xmi_to_udm_str += "						</xsl:choose>";
__xmi_to_udm_str += "						<xsl:for-each select=\"Foundation.Core.Association.connection/Foundation.Core.AssociationEnd\">";
__xmi_to_udm_str += "							<AssociationRole _id=\"{concat('id',500000 +$assoc_pos*1000 +  position())}\" min=\"{string(Foundation.Core.AssociationEnd.multiplicity/Foundation.Data_Types.Multiplicity/Foundation.Data_Types.Multiplicity.range/Foundation.Data_Types.MultiplicityRange/Foundation.Data_Types.MultiplicityRange.lower)}\" max=\"{string(Foundation.Core.AssociationEnd.multiplicity/Foundation.Data_Types.Multiplicity/Foundation.Data_Types.Multiplicity.range/Foundation.Data_Types.MultiplicityRange/Foundation.Data_Types.MultiplicityRange.upper)}\" target=\"{concat('id',substring-after(Foundation.Core.AssociationEnd.type/Foundation.Core.Classifier/@xmi.idref,'xmi.'))}\">";
__xmi_to_udm_str += "								<!-- Check if name exists -->";
__xmi_to_udm_str += "								<xsl:choose>";
__xmi_to_udm_str += "									<xsl:when test=\"string-length(Foundation.Core.ModelElement.name) > 1\">";
__xmi_to_udm_str += "										<xsl:attribute name=\"name\"><xsl:value-of select=\"Foundation.Core.ModelElement.name\"/></xsl:attribute>";
__xmi_to_udm_str += "									</xsl:when>";
__xmi_to_udm_str += "								</xsl:choose>";
__xmi_to_udm_str += "							</AssociationRole>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</Association>";
__xmi_to_udm_str += "				</xsl:when>";
__xmi_to_udm_str += "			</xsl:choose>";
__xmi_to_udm_str += "		</xsl:for-each>";
__xmi_to_udm_str += "		<!-- go through classes that are not association classes ";
__xmi_to_udm_str += "			(Class generation) 		-->";
__xmi_to_udm_str += "		<xsl:for-each select=\"Foundation.Core.Class\">";
__xmi_to_udm_str += "			<Class _id=\"{concat('id',substring-after(@xmi.id, 'xmi.'))}\" name=\"{string(Foundation.Core.ModelElement.name)}\" isAbstract=\"{Foundation.Core.GeneralizableElement.isAbstract/@xmi.value}\">";
__xmi_to_udm_str += "				<xsl:variable name=\"this_class_id\" select=\"@xmi.id\"/>";
__xmi_to_udm_str += "				<!-- computing child roles -->";
__xmi_to_udm_str += "				<xsl:variable name=\"childRoles\">";
__xmi_to_udm_str += "					<xsl:for-each select=\"../Foundation.Core.Association\">";
__xmi_to_udm_str += "						<xsl:variable name=\"assoc_pos\" select=\"number(position())\"/>";
__xmi_to_udm_str += "						<xsl:for-each select=\"Foundation.Core.Association.connection\">";
__xmi_to_udm_str += "							<!-- it will have two association ends -->";
__xmi_to_udm_str += "							<xsl:choose>";
__xmi_to_udm_str += "								<!-- need to check that's it a composition. This is done by checking the number of association ends that have the aggregation attribute set to 'composite' -->";
__xmi_to_udm_str += "								<xsl:when test=\"count(Foundation.Core.AssociationEnd/Foundation.Core.AssociationEnd.aggregation[@xmi.value = 'composite']) = 1\">";
__xmi_to_udm_str += "									<xsl:for-each select=\"Foundation.Core.AssociationEnd\">";
__xmi_to_udm_str += "										<xsl:choose>";
__xmi_to_udm_str += "											<!-- AssociationEnd point to this class -->";
__xmi_to_udm_str += "											<xsl:when test=\"string(Foundation.Core.AssociationEnd.type/Foundation.Core.Classifier/@xmi.idref) = string($this_class_id)\">";
__xmi_to_udm_str += "												<xsl:choose>";
__xmi_to_udm_str += "													<!-- get the child part of it -->";
__xmi_to_udm_str += "													<xsl:when test=\"string(Foundation.Core.AssociationEnd.aggregation/@xmi.value) = 'none'\">";
__xmi_to_udm_str += "														<xsl:variable name=\"child_role_id\" select=\"position() + number($assoc_pos)*1000 + 100000\"/>";
__xmi_to_udm_str += "														<xsl:value-of select=\"concat(concat('id',$child_role_id), ' ')\"/>";
__xmi_to_udm_str += "													</xsl:when>";
__xmi_to_udm_str += "												</xsl:choose>";
__xmi_to_udm_str += "											</xsl:when>";
__xmi_to_udm_str += "										</xsl:choose>";
__xmi_to_udm_str += "									</xsl:for-each>";
__xmi_to_udm_str += "								</xsl:when>";
__xmi_to_udm_str += "							</xsl:choose>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</xsl:for-each>";
__xmi_to_udm_str += "				</xsl:variable>";
__xmi_to_udm_str += "				<!-- end of child roles computation -->";
__xmi_to_udm_str += "				<!-- computing parent roles -->";
__xmi_to_udm_str += "				<xsl:variable name=\"parentRoles\">";
__xmi_to_udm_str += "					<xsl:for-each select=\"../Foundation.Core.Association\">";
__xmi_to_udm_str += "						<xsl:variable name=\"assoc_pos\" select=\"number(position())\"/>";
__xmi_to_udm_str += "						<xsl:for-each select=\"Foundation.Core.Association.connection\">";
__xmi_to_udm_str += "							<!-- it will have two association ends -->";
__xmi_to_udm_str += "							<xsl:choose>";
__xmi_to_udm_str += "								<!-- need to check that's it a composition. This is done by checking the number of association ends that have the aggregation attribute set to 'composite' -->";
__xmi_to_udm_str += "								<xsl:when test=\"count(Foundation.Core.AssociationEnd/Foundation.Core.AssociationEnd.aggregation[@xmi.value = 'composite']) = 1\">";
__xmi_to_udm_str += "									<xsl:for-each select=\"Foundation.Core.AssociationEnd\">";
__xmi_to_udm_str += "										<xsl:choose>";
__xmi_to_udm_str += "											<!-- AssociationEnd point to this class -->";
__xmi_to_udm_str += "											<xsl:when test=\"string(Foundation.Core.AssociationEnd.type/Foundation.Core.Classifier/@xmi.idref) = string($this_class_id)\">";
__xmi_to_udm_str += "												<xsl:choose>";
__xmi_to_udm_str += "													<!-- get the child part of it -->";
__xmi_to_udm_str += "													<xsl:when test=\"string(Foundation.Core.AssociationEnd.aggregation/@xmi.value) = 'composite'\">";
__xmi_to_udm_str += "														<xsl:variable name=\"child_role_id\" select=\"position() + number($assoc_pos)*1000 + 200000\"/>";
__xmi_to_udm_str += "														<xsl:value-of select=\"concat(concat('id',$child_role_id), ' ')\"/>";
__xmi_to_udm_str += "													</xsl:when>";
__xmi_to_udm_str += "												</xsl:choose>";
__xmi_to_udm_str += "											</xsl:when>";
__xmi_to_udm_str += "										</xsl:choose>";
__xmi_to_udm_str += "									</xsl:for-each>";
__xmi_to_udm_str += "								</xsl:when>";
__xmi_to_udm_str += "							</xsl:choose>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</xsl:for-each>";
__xmi_to_udm_str += "				</xsl:variable>";
__xmi_to_udm_str += "				<!-- end of child roles computation -->";
__xmi_to_udm_str += "				<!-- computing basetypes and subtypes -->";
__xmi_to_udm_str += "				<xsl:variable name=\"baseTypes\">";
__xmi_to_udm_str += "					<xsl:for-each select=\"Foundation.Core.GeneralizableElement.generalization/Foundation.Core.Generalization\">";
__xmi_to_udm_str += "						<xsl:for-each select=\"key('id',@xmi.idref)\">";
__xmi_to_udm_str += "							<xsl:for-each select=\"Foundation.Core.Generalization.parent/Foundation.Core.GeneralizableElement\">";
__xmi_to_udm_str += "								<!-- it will be only one -->";
__xmi_to_udm_str += "								<xsl:value-of select=\"concat(concat('id', substring-after(@xmi.idref,'xmi.')),' ')\"/>";
__xmi_to_udm_str += "							</xsl:for-each>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</xsl:for-each>";
__xmi_to_udm_str += "				</xsl:variable>";
__xmi_to_udm_str += "				<xsl:variable name=\"subTypes\">";
__xmi_to_udm_str += "					<xsl:for-each select=\"Foundation.Core.GeneralizableElement.specialization/Foundation.Core.Generalization\">";
__xmi_to_udm_str += "						<xsl:for-each select=\"key('id',@xmi.idref)\">";
__xmi_to_udm_str += "							<xsl:for-each select=\"Foundation.Core.Generalization.child/Foundation.Core.GeneralizableElement\">";
__xmi_to_udm_str += "								<!-- it will be only one -->";
__xmi_to_udm_str += "								<xsl:value-of select=\"concat(concat('id', substring-after(@xmi.idref,'xmi.')),' ')\"/>";
__xmi_to_udm_str += "							</xsl:for-each>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</xsl:for-each>";
__xmi_to_udm_str += "				</xsl:variable>";
__xmi_to_udm_str += "				<!-- writing out childroles, if any -->";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string-length($childRoles) >1\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"childRoles\"><xsl:value-of select=\"$childRoles\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "				<!-- writing out parentroles, if any -->";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string-length($parentRoles) > 1\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"parentRoles\"><xsl:value-of select=\"$parentRoles\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "				<!-- writing out baseTypes, if any -->";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string-length($baseTypes) > 1\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"baseTypes\"><xsl:value-of select=\"$baseTypes\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "				<!-- writing out subTypes, if any -->";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string-length($subTypes) > 1\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"subTypes\"><xsl:value-of select=\"$subTypes\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "				<!-- Go recursive -->";
__xmi_to_udm_str += "				<xsl:apply-templates select=\"Foundation.Core.Classifier.feature\"/>";
__xmi_to_udm_str += "			</Class>";
__xmi_to_udm_str += "		</xsl:for-each>";
__xmi_to_udm_str += "		<!-- Go through association classes,	(Class generation)		-->";
__xmi_to_udm_str += "		<xsl:for-each select=\"Foundation.Core.AssociationClass\">";
__xmi_to_udm_str += "			<xsl:variable name=\"assoc_poss\" select=\"position() + count(../Foundation.Core.Association)\"/>";
__xmi_to_udm_str += "			<Class _id=\"{concat('id',substring-after(@xmi.id, 'xmi.'))}\" name=\"{string(Foundation.Core.ModelElement.name)}\" isAbstract=\"{Foundation.Core.GeneralizableElement.isAbstract/@xmi.value}\" association=\"{concat('id', string(number($assoc_poss) + number($assoc_poss)*1000 + 400000))}\">";
__xmi_to_udm_str += "				<xsl:variable name=\"this_class_id\" select=\"@xmi.id\"/>";
__xmi_to_udm_str += "				<!-- computing child roles -->";
__xmi_to_udm_str += "				<xsl:variable name=\"childRoles\">";
__xmi_to_udm_str += "					<xsl:for-each select=\"../Foundation.Core.Association\">";
__xmi_to_udm_str += "						<xsl:variable name=\"assoc_pos\" select=\"position()\"/>";
__xmi_to_udm_str += "						<xsl:for-each select=\"Foundation.Core.Association.connection\">";
__xmi_to_udm_str += "							<!-- it will have two association ends -->";
__xmi_to_udm_str += "							<xsl:choose>";
__xmi_to_udm_str += "								<!-- need to check that's it a composition. This is done by checking the number of association ends that have the aggregation attribute set to 'composite' -->";
__xmi_to_udm_str += "								<xsl:when test=\"count(Foundation.Core.AssociationEnd/Foundation.Core.AssociationEnd.aggregation[@xmi.value = 'composite']) = 1\">";
__xmi_to_udm_str += "									<xsl:for-each select=\"Foundation.Core.AssociationEnd\">";
__xmi_to_udm_str += "										<xsl:choose>";
__xmi_to_udm_str += "											<!-- AssociationEnd point to this class -->";
__xmi_to_udm_str += "											<xsl:when test=\"string(Foundation.Core.AssociationEnd.type/Foundation.Core.Classifier/@xmi.idref) = string($this_class_id)\">";
__xmi_to_udm_str += "												<xsl:choose>";
__xmi_to_udm_str += "													<!-- get the child part of it -->";
__xmi_to_udm_str += "													<xsl:when test=\"string(Foundation.Core.AssociationEnd.aggregation/@xmi.value) = 'none'\">";
__xmi_to_udm_str += "														<xsl:variable name=\"child_role_id\" select=\"position() + number($assoc_pos)*1000 + 100000\"/>";
__xmi_to_udm_str += "														<xsl:value-of select=\"concat(concat('id',$child_role_id), ' ')\"/>";
__xmi_to_udm_str += "													</xsl:when>";
__xmi_to_udm_str += "												</xsl:choose>";
__xmi_to_udm_str += "											</xsl:when>";
__xmi_to_udm_str += "										</xsl:choose>";
__xmi_to_udm_str += "									</xsl:for-each>";
__xmi_to_udm_str += "								</xsl:when>";
__xmi_to_udm_str += "							</xsl:choose>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</xsl:for-each>";
__xmi_to_udm_str += "				</xsl:variable>";
__xmi_to_udm_str += "				<!-- end of child roles computation -->";
__xmi_to_udm_str += "				<!-- computing parent roles -->";
__xmi_to_udm_str += "				<xsl:variable name=\"parentRoles\">";
__xmi_to_udm_str += "					<xsl:for-each select=\"../Foundation.Core.Association\">";
__xmi_to_udm_str += "						<xsl:variable name=\"assoc_pos\" select=\"position()\"/>";
__xmi_to_udm_str += "						<xsl:for-each select=\"Foundation.Core.Association.connection\">";
__xmi_to_udm_str += "							<!-- it will have two association ends -->";
__xmi_to_udm_str += "							<xsl:choose>";
__xmi_to_udm_str += "								<!-- need to check that's it a composition. This is done by checking the number of association ends that have the aggregation attribute set to 'composite' -->";
__xmi_to_udm_str += "								<xsl:when test=\"count(Foundation.Core.AssociationEnd/Foundation.Core.AssociationEnd.aggregation[@xmi.value = 'composite']) = 1\">";
__xmi_to_udm_str += "									<xsl:for-each select=\"Foundation.Core.AssociationEnd\">";
__xmi_to_udm_str += "										<xsl:choose>";
__xmi_to_udm_str += "											<!-- AssociationEnd point to this class -->";
__xmi_to_udm_str += "											<xsl:when test=\"string(Foundation.Core.AssociationEnd.type/Foundation.Core.Classifier/@xmi.idref) = string($this_class_id)\">";
__xmi_to_udm_str += "												<xsl:choose>";
__xmi_to_udm_str += "													<!-- get the child part of it -->";
__xmi_to_udm_str += "													<xsl:when test=\"string(Foundation.Core.AssociationEnd.aggregation/@xmi.value) = 'composite'\">";
__xmi_to_udm_str += "														<xsl:variable name=\"child_role_id\" select=\"position() + number($assoc_pos)*1000 + 200000\"/>";
__xmi_to_udm_str += "														<xsl:value-of select=\"concat(concat('id',$child_role_id), ' ')\"/>";
__xmi_to_udm_str += "													</xsl:when>";
__xmi_to_udm_str += "												</xsl:choose>";
__xmi_to_udm_str += "											</xsl:when>";
__xmi_to_udm_str += "										</xsl:choose>";
__xmi_to_udm_str += "									</xsl:for-each>";
__xmi_to_udm_str += "								</xsl:when>";
__xmi_to_udm_str += "							</xsl:choose>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</xsl:for-each>";
__xmi_to_udm_str += "				</xsl:variable>";
__xmi_to_udm_str += "				<!-- end of child roles computation -->";
__xmi_to_udm_str += "				<!-- computing basetypes and subtypes -->";
__xmi_to_udm_str += "				<xsl:variable name=\"baseTypes\">";
__xmi_to_udm_str += "					<xsl:for-each select=\"Foundation.Core.GeneralizableElement.generalization/Foundation.Core.Generalization\">";
__xmi_to_udm_str += "						<xsl:for-each select=\"key('id',@xmi.idref)\">";
__xmi_to_udm_str += "							<xsl:for-each select=\"Foundation.Core.Generalization.parent/Foundation.Core.GeneralizableElement\">";
__xmi_to_udm_str += "								<!-- it will be only one -->";
__xmi_to_udm_str += "								<xsl:value-of select=\"concat(concat('id', substring-after(@xmi.idref,'xmi.')),' ')\"/>";
__xmi_to_udm_str += "							</xsl:for-each>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</xsl:for-each>";
__xmi_to_udm_str += "				</xsl:variable>";
__xmi_to_udm_str += "				<xsl:variable name=\"subTypes\">";
__xmi_to_udm_str += "					<xsl:for-each select=\"Foundation.Core.GeneralizableElement.specialization/Foundation.Core.Generalization\">";
__xmi_to_udm_str += "						<xsl:for-each select=\"key('id',@xmi.idref)\">";
__xmi_to_udm_str += "							<xsl:for-each select=\"Foundation.Core.Generalization.child/Foundation.Core.GeneralizableElement\">";
__xmi_to_udm_str += "								<!-- it will be only one -->";
__xmi_to_udm_str += "								<xsl:value-of select=\"concat(concat('id', substring-after(@xmi.idref,'xmi.')),' ')\"/>";
__xmi_to_udm_str += "							</xsl:for-each>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</xsl:for-each>";
__xmi_to_udm_str += "				</xsl:variable>";
__xmi_to_udm_str += "				<!-- writing out childroles, if any -->";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string-length($childRoles) > 1\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"childRoles\"><xsl:value-of select=\"$childRoles\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "				<!-- writing out parentroles, if any -->";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string-length($parentRoles) > 1\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"parentRoles\"><xsl:value-of select=\"$parentRoles\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "				<!-- writing out baseTypes, if any -->";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string-length($baseTypes) > 1\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"baseTypes\"><xsl:value-of select=\"$baseTypes\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "				<!-- writing out subTypes, if any -->";
__xmi_to_udm_str += "				<xsl:choose>";
__xmi_to_udm_str += "					<xsl:when test=\"string-length($subTypes) > 1\">";
__xmi_to_udm_str += "						<xsl:attribute name=\"subTypes\"><xsl:value-of select=\"$subTypes\"/></xsl:attribute>";
__xmi_to_udm_str += "					</xsl:when>";
__xmi_to_udm_str += "				</xsl:choose>";
__xmi_to_udm_str += "				<!-- Go recursive -->";
__xmi_to_udm_str += "				<xsl:apply-templates select=\"Foundation.Core.Classifier.feature\"/>";
__xmi_to_udm_str += "			</Class>";
__xmi_to_udm_str += "		</xsl:for-each>";
__xmi_to_udm_str += "		<!-- Composition defintions -->";
__xmi_to_udm_str += "		<xsl:for-each select=\"Foundation.Core.Association\">";
__xmi_to_udm_str += "			<xsl:variable name=\"assoc_pos\" select=\"position()\"/>";
__xmi_to_udm_str += "			<xsl:choose>";
__xmi_to_udm_str += "				<xsl:when test=\"count(Foundation.Core.Association.connection/Foundation.Core.AssociationEnd/Foundation.Core.AssociationEnd.aggregation[@xmi.value = 'composite']) = 1\">";
__xmi_to_udm_str += "					<Composition>";
__xmi_to_udm_str += "						<!-- Check if name exists -->";
__xmi_to_udm_str += "						<xsl:choose>";
__xmi_to_udm_str += "							<xsl:when test=\"string-length(Foundation.Core.ModelElement.name) > 1\">";
__xmi_to_udm_str += "								<xsl:attribute name=\"name\"><xsl:value-of select=\"Foundation.Core.ModelElement.name\"/></xsl:attribute>";
__xmi_to_udm_str += "							</xsl:when>";
__xmi_to_udm_str += "						</xsl:choose>";
__xmi_to_udm_str += "						<xsl:for-each select=\"Foundation.Core.Association.connection/Foundation.Core.AssociationEnd\">";
__xmi_to_udm_str += "							<xsl:choose>";
__xmi_to_udm_str += "								<xsl:when test=\"Foundation.Core.AssociationEnd.aggregation/@xmi.value = 'composite'\">";
__xmi_to_udm_str += "									<!-- UDM's UML.DTD requests elements in the alphabetical order of their type-->";
__xmi_to_udm_str += "									<xsl:for-each select=\"../Foundation.Core.AssociationEnd\">";
__xmi_to_udm_str += "										<xsl:choose>";
__xmi_to_udm_str += "											<xsl:when test=\"Foundation.Core.AssociationEnd.aggregation/@xmi.value != 'composite'\">";
__xmi_to_udm_str += "											";
__xmi_to_udm_str += "												<CompositionChildRole _id=\"{concat('id',string(number($assoc_pos)*1000 + 100000 + position()))}\" min=\"{Foundation.Core.AssociationEnd.multiplicity/Foundation.Data_Types.Multiplicity/Foundation.Data_Types.Multiplicity.range/Foundation.Data_Types.MultiplicityRange/Foundation.Data_Types.MultiplicityRange.lower}\" max=\"{Foundation.Core.AssociationEnd.multiplicity/Foundation.Data_Types.Multiplicity/Foundation.Data_Types.Multiplicity.range/Foundation.Data_Types.MultiplicityRange/Foundation.Data_Types.MultiplicityRange.upper}\" target=\"{concat('id',substring-after(Foundation.Core.AssociationEnd.type/Foundation.Core.Classifier/@xmi.idref,'xmi.'))}\">";
__xmi_to_udm_str += "													<!-- Check if name exists -->";
__xmi_to_udm_str += "													<xsl:choose>";
__xmi_to_udm_str += "														<xsl:when test=\"string-length(Foundation.Core.ModelElement.name) > 1\">";
__xmi_to_udm_str += "															<xsl:attribute name=\"name\"><xsl:value-of select=\"Foundation.Core.ModelElement.name\"/></xsl:attribute>";
__xmi_to_udm_str += "														</xsl:when>";
__xmi_to_udm_str += "													</xsl:choose>";
__xmi_to_udm_str += "												</CompositionChildRole>";
__xmi_to_udm_str += "											</xsl:when>";
__xmi_to_udm_str += "										</xsl:choose>";
__xmi_to_udm_str += "									</xsl:for-each>";
__xmi_to_udm_str += "									<CompositionParentRole _id=\"{concat('id',string(number($assoc_pos)*number('1000') + number('200000') + number(position())))}\" target=\"{concat('id',substring-after(Foundation.Core.AssociationEnd.type/Foundation.Core.Classifier/@xmi.idref,'xmi.'))}\">";
__xmi_to_udm_str += "										<!-- Check if name exists -->";
__xmi_to_udm_str += "										<xsl:choose>";
__xmi_to_udm_str += "											<xsl:when test=\"string-length(Foundation.Core.ModelElement.name) > 1\">";
__xmi_to_udm_str += "												<xsl:attribute name=\"name\"><xsl:value-of select=\"Foundation.Core.ModelElement.name\"/></xsl:attribute>";
__xmi_to_udm_str += "											</xsl:when>";
__xmi_to_udm_str += "										</xsl:choose>";
__xmi_to_udm_str += "									</CompositionParentRole>";
__xmi_to_udm_str += "								</xsl:when>";
__xmi_to_udm_str += "							</xsl:choose>";
__xmi_to_udm_str += "						</xsl:for-each>";
__xmi_to_udm_str += "					</Composition>";
__xmi_to_udm_str += "				</xsl:when>";
__xmi_to_udm_str += "			</xsl:choose>";
__xmi_to_udm_str += "		</xsl:for-each>";
__xmi_to_udm_str += "	</xsl:template>";
__xmi_to_udm_str += "	<!-- match these and do nothing -->";
__xmi_to_udm_str += "	<xsl:template match=\"Foundation.Core.ModelElement.name\"/>";
__xmi_to_udm_str += "	<xsl:template match=\"Foundation.Core.ModelElement.isSpecification\"/>";
__xmi_to_udm_str += "	<xsl:template match=\"Foundation.Core.GeneralizableElement.isRoot\"/>";
__xmi_to_udm_str += "	<xsl:template match=\"Foundation.Core.GeneralizableElement.isLeaf\"/>";
__xmi_to_udm_str += "	<xsl:template match=\"Foundation.Core.GeneralizableElement.isAbstract\"/>";
__xmi_to_udm_str += "	<!-- Match Model_Management.Model ; generate diagram and go recursive-->";
__xmi_to_udm_str += "	<xsl:template match=\"Model_Management.Model\">";
__xmi_to_udm_str += "		<Diagram name=\"{string(Foundation.Core.ModelElement.name)}\">";
__xmi_to_udm_str += "		<xsl:attribute name=\"xsi:noNamespaceSchemaLocation\">Uml.xsd</xsl:attribute>	";			
__xmi_to_udm_str += "			<xsl:apply-templates/>";
__xmi_to_udm_str += "		</Diagram>";
__xmi_to_udm_str += "	</xsl:template>";
__xmi_to_udm_str += "	<xsl:template match=\"XMI.header\"/>";
__xmi_to_udm_str += "	<!-- XMI header; do nothing -->";
__xmi_to_udm_str += "	<xsl:template match=\"XMI.content\">";
__xmi_to_udm_str += "		<!-- XMI.content; do nothing & go recursive -->";
__xmi_to_udm_str += "		<xsl:apply-templates/>";
__xmi_to_udm_str += "	</xsl:template>";
__xmi_to_udm_str += "	<xsl:template match=\"/\">";
__xmi_to_udm_str += "		<!-- Root ; do nothing & go recursive -->";
__xmi_to_udm_str += "		<xsl:apply-templates/>";
__xmi_to_udm_str += "	</xsl:template>";
__xmi_to_udm_str += "</xsl:stylesheet>";

		
		return;
	}


